# Seurat Pipeline

library(tidyverse)
library(ggpubr)
library(ggprism)
library(Seurat)
conflicted::conflict_prefer_all("dplyr", quiet = TRUE)

# DO NOT USE SEURAT V5 -> V5 objects do not play nicely yet with CellOracle in Python
options(Seurat.object.assay.version = "v3")

kaveh_colors1 <- c("#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571")
kaveh_colors2 <- c("#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b")
kaveh_colors3 <- c("#ff0000", "#f5f5f5","#0000ff")


config_dir <- "./config/"
data_dir <- "./data/"
model_dir <- "./models/"
results_dir <- "./results/"
figures_dir <- "./figures/"

# Parallell Processing
#future::plan(future::multisession, workers = future::availableCores() - 2)
num_cores <- future::availableCores()
if(num_cores > 3) {
  library(doParallel)
  
  cl <- makePSOCKcluster(num_cores - 2)
  registerDoParallel(cl)
}

processSingleCell <- function(config, seurat_verbose = FALSE) {
  
  # Set reasonable defaults
  config$percent_mito <- ifelse(is.null(config$percent_mito), 10, config$percent_mito)
  config$normalization <- ifelse(is.null(config$normalization), "log", config$normalization)
  config$seurat_assay <- ifelse("sct" == config$normalization, "SCT", "RNA")
  
  seurat_objs <- list()
  
  cat("Processing: ", config$filename, "\n")
  cat("Load sample 10X data...\n")
  cat("Initial sample QC cutoffs - min.cells = 3, num genes > 200, num genes < 6k, percent.mito < ", config$percent_mito, "\n")
  
  for (sample in config$samples) {
    sample_counts <- Read10X_h5(paste0(sample$path, "/filtered_feature_bc_matrix.h5"))
    
    cat("Sample", sample$date, 
        sample$location, sample$condition, sample$celltype, 
        ":", nrow(sample_counts), "genes x", ncol(sample_counts), "cells\n")
    
    obj <- CreateSeuratObject(sample_counts, project = config$project, min.cells = 3, min.features = 200)
    
    # Initial QC (mitochondrial genes, low features, doublets)
    obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern="^MT-|^mt-")
    
    #Used below plots to get approx. nCount_RNA cut-off of ~20k
    print(VlnPlot(obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3))
    
    #obj <- subset(obj, subset = nFeature_RNA > 200 & nCount_RNA < 20000 & percent.mt < 6)
    obj <- subset(obj, subset = nFeature_RNA > 200 & nFeature_RNA < 6000 & percent.mt < config$percent_mito)
    
    cat("After QC filtering:", nrow(obj), "genes x", ncol(obj), "cells\n\n")
    
    # Add metadata
    for (key in names(sample)) {
      if (!(key %in% c("path")) & !is.null(sample[[key]])) { 
        obj <- AddMetaData(obj, sample[[key]], key)
      }
    }
    
    # Add to the list of seurat_objs
    seurat_objs[[sample$id]] <- obj
  }
  
  ### Neurons
  # Read in SmartSeq count matrix (should have cells as columns and genes as rows)
  # neuron_counts <- readr::read_csv("../_DATASETS/NeuroImmune/control_corneal_afferent_counts_filtered.csv",
  #                                  show_col_types = FALSE) %>%
  #   column_to_rownames(var = "gene")
  # 
  # neuron_counts <- neuron_counts[, colSums(neuron_counts) > 0] %>%
  #   as.matrix() %>%
  #   Matrix::Matrix(sparse = T)
  # 
  # neuron_obj <- CreateSeuratObject(neuron_counts,
  #                                  project = "NeuroImmune")
  # 
  # cat("Neurons:", nrow(neuron_obj), "genes x", ncol(neuron_obj), "cells")
  # 
  # neuron_obj$id <- "HandpickedControlCornealAfferents"
  # neuron_obj$date <- "neuron_date"
  # neuron_obj$condition <- "control"
  # neuron_obj$location <- "corneal_afferents"
  # neuron_obj$celltype <- "neuron"
  # neuron_obj$timepoint <- ""
  # 
  # # Skipping QC on neurons since they were hand-picked single cells (although possibly should still do
  # # % mitochondrial DNA filtering).
  # 
  # seurat_objs[["neurons"]] <- neuron_obj
  
  
  ## Merge 
  merged_seurat <- merge(x = seurat_objs[[1]],
                         y = seurat_objs[2:length(seurat_objs)],
                         merge.data = TRUE)
  
  
  ## Create an AnnData object (with just the raw/unnormalized counts) to use with the CellOracle pipeline
  # SeuratDisk::SaveH5Seurat(merged_seurat, filename = paste0(data_dir, config$filename, ".h5Seurat"), overwrite = TRUE)
  # SeuratDisk::Convert(source = paste0(data_dir, config$filename, ".h5Seurat"), 
  #                     dest = paste0(data_dir, config$filename, ".h5ad"), 
  #                     overwrite = TRUE)
  # file.remove(paste0(data_dir, config$filename, ".h5Seurat"))  # remove the temporary/unneeded .h5Seurat file
  
  #Normalize then Harmony Integrate
  if ("log" == config$normalization) {
    merged_seurat <- NormalizeData(merged_seurat, verbose = seurat_verbose) %>% 
      FindVariableFeatures(verbose = seurat_verbose) %>% 
      ScaleData(verbose = seurat_verbose, features = rownames(merged_seurat)) %>% 
      #RunPCA(verbose = seurat_verbose, features = config$pca_features) %>% 
      RunPCA(verbose = seurat_verbose) %>% 
      FindNeighbors(dims = 1:30, reduction = "pca", verbose = seurat_verbose) %>% 
      FindClusters(resolution = 0.8, verbose = seurat_verbose) %>% 
      RunUMAP(dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated", verbose = seurat_verbose)
    
  } else if ("sct" == config$normalization) {
    merged_seurat <- SCTransform(merged_seurat,
                                 vst.flavor = "v2",
                                 vars.to.regress = "percent.mt",
                                 return.only.var.genes = seurat_verbose,
                                 verbose = seurat_verbose) %>%
      RunPCA(assay = "SCT", npcs = 50, verbose = seurat_verbose) %>%
      FindNeighbors(dims = 1:50, reduction = "pca", verbose = seurat_verbose) %>%
      FindClusters(resolution = 0.8, verbose = seurat_verbose) %>%
      RunUMAP(dims = 1:50, reduction = "pca", reduction.name = "umap.unintegrated", verbose = seurat_verbose)
  } else {
    stop("Normalization type not specified in config file.")
  }
  
  ## Harmony Integration
  harmonized_seurat <- harmony::RunHarmony(merged_seurat, 
                                           group.by.vars = c("id"),
                                           #group.by.vars = c("id", "date", "condition"),
                                           #group.by.vars = c("id", "condition"),
                                           reduction = "pca",
                                           assay.use = config$seurat_assay,
                                           reduction.save = "harmony")
  
  harmonized_seurat <- RunUMAP(harmonized_seurat, 
                               reduction = "harmony", 
                               reduction.name = "umap.harmony",
                               assay = config$seurat_assay,
                               dims = 1:50)
  
  harmonized_seurat <- FindNeighbors(object = harmonized_seurat, reduction = "harmony", verbose = seurat_verbose)
  #harmonized_seurat <- FindClusters(harmonized_seurat, resolution = seq(from = 0.5, to = 2.0, by = 0.15), verbose = seurat_verbose)
  
  
  harmonized_seurat <- FindClusters(harmonized_seurat, resolution = 1.0, verbose = seurat_verbose)
  
  # Save to Disk
  #harmonized_seurat %>% readr::write_rds(paste0(data_dir, config$filename, ".rds"))
  harmonized_seurat %>% SeuratDisk::SaveH5Seurat(paste0(data_dir, config$filename, ".h5Seurat"), overwrite = TRUE, verbose = seurat_verbose)
}

#configs <- c("june_tg_sct.yaml", "aug_tg_sct.yaml", "july_cornea_sct.yaml", "sept_cornea_sct.yaml")
configs <- c("tg_combined.yaml")

for (config in configs) {
  loaded_config <- yaml::read_yaml(paste0(config_dir, config))
  
  processSingleCell(loaded_config, seurat_verbose = TRUE)
}

